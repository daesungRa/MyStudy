
![author](https://img.shields.io/badge/author-daesungRa-lightgray.svg?style=flat-square)
![date](https://img.shields.io/badge/date-191009-lightgray.svg?style=flat-square)

# Introduction to Algorithms (Third Edition, 2009)

#### Contents

1. 기초
    - 소개    3
    1. 컴퓨팅에서 알고리즘의 역할    5
    
        - 알고리즘    5
        - 기술로써의 알고리즘    11
        
    2. 시작하기    16
    
        - 삽입 정렬    16

## 1    기초

#### 소개

이 파트는 당신으로 하여금 알고리즘 설계와 분석에 대한 생각을 시작할 수 있도록 한다.
이것은 알고리즘을 정의하는 방식, 이 책 전반에 걸쳐 사용할 몇몇 설계 전략,
그리고 알고리즘 분석에서 사용될 많은 기초적인 개념들에 대한 부드러운 소개가 되도록 의도되었다.
이 권 이후의 파트는 이것을 기반으로 세워질 것이다.

챕터 1 은 알고리즘의 개요와 현대 컴퓨팅 시스템에서 그것의 위치를 제공한다.
이 챕터는 알고리즘이 무엇인지 정의하고 몇몇 예제들을 목록화한다.
또한 우리로 하여금 빠른 하드웨어, 그래픽 사용자 인터페이스, 객체지향 시스템, 그리고 네트워크와 같은 기술들과 함께
기술로써의 알고리즘이란 무엇인가에 대해 생각해 보도록 하는 케이스를 제공한다.

챕터 2 에서 우리는 *n* 개의 숫자들의 순서를 정렬하는 문제를 푸는 우리의 첫 알고리즘들을 만나볼 수 있다.
이것들은 의사코드(pseudocode)로 작성되었는데, 어떠한 일반적 프로그래밍 언어로도 직접적으로 번역 가능하지는 않지만,
이것은 당신 스스로 선택한 언어로 구현할 수 있도록 알고리즘의 구조로 충분히 분명하게 이끌어준다.
우리가 설명하는 정렬 알고리즘들은 증가하는 방식을 사용하는 삽입 정렬,
"divide-and-conquer."(분할 정복?) 로 알려진 재귀적 기술을 사용하는 병합 정렬이 있다.
*n* 의 값과 함께 각 알고리즘이 요구하는 시간은 공통적으로 증가하지만, 증가율은 서로 다르다.
우리는 이러한 실행 시간(running times)을 챕터 2 에서 정의할 것이며, 이를 설명하는 유용한 기법을 개발할 것이다.

챕터 3 은 점근 표기법(asymptotic notation)이라고 부르는 기법을 명료하게 정의한다.
**이것은 우리가 and/or 이후로부터 경계 알고리즘(bounding algorithm) 실행 시간을 위해 사용하는 몇몇 점근 표기법들을 정의함으로써 시작한다.**
챕터 3 의 나머지 부분은 새로운 수학적 개념을 가르치기 보다는,
당신이 사용하는 기법을 이 책에 있는 것과 더욱 일치하도록 하기 위한 수학적 기법에 대한 설명으로 우선적으로 구성되어 있다.

챕터 4 에서는 챕터 2 에서 소개된 분할 정복 방법론으로 더 깊게 들어간다.
이것은 두 정사각 행렬로 분할하는 Strassen 의 놀라운 메서드를 포함하는 분할 정복 알고리즘의 추가적인 예제들을 제공한다.
챕터 4 는 재귀 알고리즘의 실행 시간을 설명하는 데 유용한 회귀 문제를 해결하는 메서드들을 포함한다.
(여기서) 하나의 강력한 테크닉은 분할 정복 알고리즘으로부터 되살아나는 회귀 문제들을
해결하기 위해 종종 사용하는 "마스터 메서드(master method)"이다.
챕터 4 는 이 마스터 메서드의 정확성을 증명하는 데에 많은 노력을 들이고 있으나,
만약 마스터 메서드에 아직 여전히 익숙하지 않다면 이 증명을 건너뛰어도 무방하다.

챕터 5 는 확률적 분석과 무작위 알고리즘을 소개한다.
우리는 전형적으로 같은 사이즈의 다른 입력이 실행 시간을 서로 다르게 하는 내재된 확률 분포가 존재하는 상황에서
알고리즘의 실행 시간을 정의하기 위하여 확률적 분석을 사용한다.
몇몇 상황에서 가능한 모든 입력값들에 대한 실행 시간을 평균내기 위하여 우리는 입력값들이 이미 알려져 있는 확률 분포를 따른다고 가정한다.
그러나 다른 상황에서 확률 분포는 입력값이 아니라 알고리즘의 진행 동안에 만들어진 무작위 선택으로부터 말미암는다.
입력값 뿐만 아니라 무작위 번호 생성기에 의해 생성된 값들에 의해 결정되는 동작을 가진 알고리즘은 무작위 알고리즘이다.
**우리는 입력값-이것으로 인해 어떠한 특정 입력도 항상 열악한 성능을 야기하지 않도록 한다- 또는
제한된 기반 위에서 부정확한 결과값을 생성하는 것이 허용되는 알고리즘 에러율을 경계짓는 것에
확률 분포를 적용하기 위하여 이 무작위 알고리즘을 사용할 수 있다.
(We can use randomized algorithms to enforce a probability distribution on the inputs
-thereby ensuring that no particular input always causes poor performance-
or even to bound the error rate of algorithms that are allowed to produce incorrect results on a limited bases.)**

부록 A-D 는 당신이 이 책을 읽는 데 도움이 될 다른 수학적 도구들을 포함한다.
당신은 아마 이 책을 읽기 전에 부록 챕터에 수록된 많은 도구들을 이미 보았을 것이고
(그럼에도 우리가 사용하는 특정 정의들과 표기법들은 몇몇 경우에서 당신이 과거에 보았던 것들과 다를지도 모른다),
이 부록 부분을 참조 도구로써 생각할 것이다.
그러나 다른 한 편에서 당신은 파트 1 의 대부분의 도구를 아직 보지 못했을지 모른다.
파트 1 의 모든 챕터와 부록은 맛보기 튜토리얼로써 쓰여졌다.

### 1    컴퓨팅에서 알고리즘의 역할

> 알고리즘이란 무엇인가? 왜 알고리즘을 공부하는 것이 가치 있는 일인가?
컴퓨터를 사용하는 다른 기술들과 관련해서 알고리즘의 역할은 무엇인가? 이 챕터에서는 이러한 질문들에 대답한다.

#### 1.1    알고리즘

비공식적으로 **알고리즘**은 **입력**으로 몇몇 값이나 값의 집합을 받아 **출력**으로 몇몇 값이나 값의 집합을 생성하는 잘 정의된 계산적 절차이다.
알고리즘은 입력을 출력으로 변환하는 일련의 계산 과정이다.
