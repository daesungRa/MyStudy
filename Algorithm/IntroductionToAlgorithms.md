
![author](https://img.shields.io/badge/author-daesungRa-lightgray.svg?style=flat-square)
![date](https://img.shields.io/badge/date-191009-lightgray.svg?style=flat-square)

# Introduction to Algorithms (Third Edition, 2009)

Reference:  [[번역] Introduction to Algorithms-CLRS](https://github.com/CodeClub-JU/Introduction-to-Algorithms-CLRS/blob/master/Introduction%20to%20Algorithms%20-%203rd%20Edition.pdf)

#### Contents

1. 기초
    - 소개 (3)
    1. 컴퓨팅에서 알고리즘의 역할 (5)
    
        - 알고리즘 (5)
        - 기술로써의 알고리즘 (11)
        
    2. 시작하기 (16)
    
        - 삽입 정렬 (16)
        - 알고리즘 분석 (23)
        - 알고리즘 설계 (29)
    
    3. 함수 확장 (43)
    
        - 점근 표기법 (43)
        - 표준 기법과 일반적인 함수들 (53)
    
    4. 분할 정복(Divide-and-Conquer) (65)
    5. 확률 분석과 무작위 알고리즘 (114)
    
2. 정렬 및 순서 통계

    - 소개 (147)
    6. 힙정렬 (151)
    7. 퀵정렬 (170)
    8. 선형 시계열에서 정렬 (191)
    9. 중앙값 및 순서 통계 (213)
    
3. 데이터 구조

    소개 (229)
    10. 기본 데이터 구조 (232)
    11. 해시 테이블 (253)
    12. 이진 검색 트리 (286)
    13. 레드블랙 트리 (308)
    14. 확장 데이터 구조 (339)
    
4. 진보된 설계 및 분석 기술
    
    - 소개 (357)
    
5. 진보된 데이터 구조
6. 그래프 알고리즘
7. 선택된 주제들
8. 부록: 수학적 제반도구

## 들어가며

컴퓨터가 있기 전에 알고리즘이 있었다.
그러나 지금은 컴퓨터가 있고, 그곳에는 더 많은 알고리즘이 있으며, 이 알고리즘들은 컴퓨팅의 중심부에 자리잡고 있다.

이 책은 컴퓨터 알고리즘의 현대적인 연구에 대한 포괄적인 소개를 제공한다.
이것은 많은 알고리즘을 선물하고 그것들을 상당한 깊이로 다루며, 모든 수준의 독자들로 하여금 그들의 디자인과 분석에 쉽게 접근할 수 있도록 한다.
우리는 다루는 범주나 수학적 엄밀성의 깊이를 희생하지 않는 가운데 초등 수준의 설명을 유지할 수 있도록 노력했다.

각 챕터는 알고리즘, 설계 테크닉, 어플리케이션 영역, 또는 관련된 주제를 선물한다.
알고리즘은 영어와 기본적인 프로그래밍 지식이 있는 사람이라면 누구나 읽을 수 있도록 설계된 의사 코드로 설명된다.
이 책은 알고리즘의 동작을 그리는 (여러 파트를 가진 많은) 244 개의 형태를 포함한다.
*efficiency* 를 디자인 표준으로써 강조했기 때문에, 우리는 우리의 모든 알고리즘의 실행 시간에 대한 주의 깊은 분석을 포함한다.

이 텍스트는 우선적으로 알고리즘이나 데이터 구조 코스 재학생 혹은 졸업생의 사용을 위해 의도되었다.
왜냐하면 이것은 기술적 전문성에 따라 스스로 공부하는 것에 최적화된 수학적 관점 만큼이나 유사하게
알고리즘 설계에서 공학적 이슈를 논의하고 있기 때문이다.

이 세 번째 개정판에서 우리는 다시 한 번 책의 전체적인 부분을 최신화했다.
이 변화는 새로운 챕터, 수정된 의사코드, 그리고 더 활발한 글쓰기 스타일을 포함하는 넓은 스펙트럼을 다룬다.

## 1    기초

#### 소개

이 파트는 당신으로 하여금 알고리즘 설계와 분석에 대한 생각을 시작할 수 있도록 한다.
이것은 알고리즘을 정의하는 방식, 이 책 전반에 걸쳐 사용할 몇몇 설계 전략,
그리고 알고리즘 분석에서 사용될 많은 기초적인 개념들에 대한 부드러운 소개가 되도록 의도되었다.
이 권 이후의 파트는 이것을 기반으로 세워질 것이다.

챕터 1 은 알고리즘의 개요와 현대 컴퓨팅 시스템에서 그것의 위치를 제공한다.
이 챕터는 알고리즘이 무엇인지 정의하고 몇몇 예제들을 목록화한다.
또한 우리로 하여금 빠른 하드웨어, 그래픽 사용자 인터페이스, 객체지향 시스템, 그리고 네트워크와 같은 기술들과 함께
기술로써의 알고리즘이란 무엇인가에 대해 생각해 보도록 하는 케이스를 제공한다.

챕터 2 에서 우리는 *n* 개의 숫자들의 순서를 정렬하는 문제를 푸는 우리의 첫 알고리즘들을 만나볼 수 있다.
이것들은 의사코드(pseudocode)로 작성되었는데, 어떠한 일반적 프로그래밍 언어로도 직접적으로 번역 가능하지는 않지만,
이것은 당신 스스로 선택한 언어로 구현할 수 있도록 알고리즘의 구조로 충분히 분명하게 이끌어준다.
우리가 설명하는 정렬 알고리즘들은 증가하는 방식을 사용하는 삽입 정렬,
"divide-and-conquer."(분할 정복?) 로 알려진 재귀적 기술을 사용하는 병합 정렬이 있다.
*n* 의 값과 함께 각 알고리즘이 요구하는 시간은 공통적으로 증가하지만, 증가율은 서로 다르다.
우리는 이러한 실행 시간(running times)을 챕터 2 에서 정의할 것이며, 이를 설명하는 유용한 기법을 개발할 것이다.

챕터 3 은 점근 표기법(asymptotic notation)이라고 부르는 기법을 명료하게 정의한다.
**이것은 우리가 and/or 이후로부터 경계 알고리즘(bounding algorithm) 실행 시간을 위해 사용하는 몇몇 점근 표기법들을 정의함으로써 시작한다.**
챕터 3 의 나머지 부분은 새로운 수학적 개념을 가르치기 보다는,
당신이 사용하는 기법을 이 책에 있는 것과 더욱 일치하도록 하기 위한 수학적 기법에 대한 설명으로 우선적으로 구성되어 있다.

챕터 4 에서는 챕터 2 에서 소개된 분할 정복 방법론으로 더 깊게 들어간다.
이것은 두 정사각 행렬로 분할하는 Strassen 의 놀라운 메서드를 포함하는 분할 정복 알고리즘의 추가적인 예제들을 제공한다.
챕터 4 는 재귀 알고리즘의 실행 시간을 설명하는 데 유용한 회귀 문제를 해결하는 메서드들을 포함한다.
(여기서) 하나의 강력한 테크닉은 분할 정복 알고리즘으로부터 되살아나는 회귀 문제들을
해결하기 위해 종종 사용하는 "마스터 메서드(master method)"이다.
챕터 4 는 이 마스터 메서드의 정확성을 증명하는 데에 많은 노력을 들이고 있으나,
만약 마스터 메서드에 아직 여전히 익숙하지 않다면 이 증명을 건너뛰어도 무방하다.

챕터 5 는 확률적 분석과 무작위 알고리즘을 소개한다.
우리는 전형적으로 같은 사이즈의 다른 입력이 실행 시간을 서로 다르게 하는 내재된 확률 분포가 존재하는 상황에서
알고리즘의 실행 시간을 정의하기 위하여 확률적 분석을 사용한다.
몇몇 상황에서 가능한 모든 입력값들에 대한 실행 시간을 평균내기 위하여 우리는 입력값들이 이미 알려져 있는 확률 분포를 따른다고 가정한다.
그러나 다른 상황에서 확률 분포는 입력값이 아니라 알고리즘의 진행 동안에 만들어진 무작위 선택으로부터 말미암는다.
입력값 뿐만 아니라 무작위 번호 생성기에 의해 생성된 값들에 의해 결정되는 동작을 가진 알고리즘은 무작위 알고리즘이다.
**우리는 입력값-이것으로 인해 어떠한 특정 입력도 항상 열악한 성능을 야기하지 않도록 한다- 또는
제한된 기반 위에서 부정확한 결과값을 생성하는 것이 허용되는 알고리즘 에러율을 경계짓는 것에
확률 분포를 적용하기 위하여 이 무작위 알고리즘을 사용할 수 있다.
(We can use randomized algorithms to enforce a probability distribution on the inputs
-thereby ensuring that no particular input always causes poor performance-
or even to bound the error rate of algorithms that are allowed to produce incorrect results on a limited bases.)**

부록 A-D 는 당신이 이 책을 읽는 데 도움이 될 다른 수학적 도구들을 포함한다.
당신은 아마 이 책을 읽기 전에 부록 챕터에 수록된 많은 도구들을 이미 보았을 것이고
(그럼에도 우리가 사용하는 특정 정의들과 표기법들은 몇몇 경우에서 당신이 과거에 보았던 것들과 다를지도 모른다),
이 부록 부분을 참조 도구로써 생각할 것이다.
그러나 다른 한 편에서 당신은 파트 1 의 대부분의 도구를 아직 보지 못했을지 모른다.
파트 1 의 모든 챕터와 부록은 맛보기 튜토리얼로써 쓰여졌다.

### 1 컴퓨팅에서 알고리즘의 역할

> 알고리즘이란 무엇인가? 왜 알고리즘을 공부하는 것이 가치 있는 일인가?
컴퓨터를 사용하는 다른 기술들과 관련해서 알고리즘의 역할은 무엇인가? 이 챕터에서는 이러한 질문들에 대답한다.

#### 1.1    알고리즘

비공식적으로 **알고리즘**은 **입력**으로 몇몇 값이나 값의 집합을 받아 **출력**으로 몇몇 값이나 값의 집합을 생성하는 잘 정의된 계산적 절차이다.
알고리즘은 입력을 출력으로 변환하는 일련의 계산 과정이다.
우리는 또한 알고리즘을 잘 정의된 **computational problem** 을 해결하기 위한 도구로 볼 수 있다.
문제에 대한 진술은 기대되는 입력/출력 간의 관계를 일반 용어로 규정한다.
알고리즘은 입력/출력 관계를 완성시키기 위해서 특정한 computational procedure 를 설명한다.

예를 들어 nondecreasing order 로 일종의 순차적 숫자들의 정렬을 구한다고 해보자.
이러한 문제는 실무에서도 빈번하게 발생하며, 많은 표준 설계기법과 분석 도구를 소개하기 위한 비옥한 토대를 제공한다.
다음은 우리가 정렬 문제를 공식적으로 정의하는 방법이다.

```html
<strong>Input</strong>: A sequence of n numbers (a1, a2, ... , an)
<strong>Output</strong>: A permutation (reordering) (aa1, aa2, ... , aan) of the input sequence such that a1 <= a2 <= ... <= an.
```

예를 들어 <31 ,41, 59, 26, 41, 58> 에 해당하는 입력 시퀀스가 주어졌을 때, 정렬 알고리즘은 <26, 31, 41, 41, 58, 59> 시퀀스를 반환한다.
이러한 입력 시퀀스는 an **instance** of the sorting problem 으로 불린다.
일반적으로, an **instance of a problem** 은 문제의 해결법을 실행하기 위해 요구되는 입력으로 구성된다.
(이 입력은 문제의 진술에 있는 어떠한 제약조건이든지 만족한다.)

왜냐하면 중급 단계로 이것을 사용하는 많은 프로그램들에게 있어서 정렬은 컴퓨터공학 내에서 기본적인 동작이다.
결과적으로 우리는 많은 수의 좋은 정렬 알고리즘들을 가지고 있다.
주어진 어플리케이션에 가장 최적의 알고리즘이 무엇인가 하는 문제는 다른 여러 요인들 중에서도
정렬에 필요한 요소들의 개수, 어떤 요소들이 이미 어느정도 정렬되어 있는가에 대한 범주,
요소의 값들에 존재할법 한 제약 사항들, 컴퓨터의 구조, 그리고 사용될 저장 디바이스의 종류(메인 메모리, 디스크, 또는 테이프) 등에 달려 있다.

모든 입력 인스턴스가 주어졌을 때 정확한 출력과 함께 (절차가)종료된다면 해당 알고리즘은 정확하다고 말할 수 있다.
우리는 정확한 알고리즘은 주어진 전산 문제를 해결한다고 말한다.
부정확한 알고리즘은 몇몇 입력 인스턴스가 주어졌을 때 전혀 종료되지 않거나, 부정확한 결과값과 함께 종료된다.
당신이 기대할 수 있는 것과는 반대로 부정확한 알고리즘은 그것의 오류율을 통제할 수 있다면 때때로 유용할 수 있다.
차후 큰 소수를 찾는 알고리즘을 공부할 때, 챕터 31에서 통제 가능한 오류율을 가진 이러한 알고리즘 예제를 보게 될 것이다.
그러나 일반적으로 우리는 오직 정확한 알고리즘에 대해서만 고려하게 될 것이다.

알고리즘은 컴퓨터 프로그램으로서의 영어, 혹은 심지어 하드웨어 설계로서의 영어로 정의될 수 있다.
여기서 요구되는 단 하나는, 이 정의는 잇따라 올 전산 절차에 대한 선험적인 설명을 제공해야 한다는 것이다.

**어떤 종류의 문제들이 알고리즘에 의해 해결되는가?**

정렬은 어떤 알고리즘이 발전되어 왔는가에 대한 전산적 문제만을 의미하는 것은 아니다.
(당신은 아마도 이 책의 분량을 보았을 때 많이 의심될지 모른다.)
알고리즘에 대한 실용적인 어플리케이션들은 어디에나 존재하며 다음의 예시들을 포함한다.

- 인간 게놈 프로젝트는 인간 DNA 안에 존재하는 십만 개의 모든 유전자를 식별하고,
인간 DNA 로 만들어지는 일련의 30억 개의 화학적 쌍을 정의하며,
데이터베이스에 이 정보를 저장하고 데이터 분석을 위해 도구를 개발하는 것 등에 목적을 두고 있는 훌륭한 절차로 만들어졌다.
이러한 각 절차들은 매우 복잡한 알고리즘을 요구한다.
비록 이것에 포함되는 다양한 문제들의 해결법들이 이 책의 범주를 넘어서더라도,
이러한 생물학적 문제들을 푸는 메서드들은 이 책의 몇몇 챕터들로부터 나온 아이디어를 사용하며,
이에 따라 과학자로 하여금 요소들을 효율적으로 사용함으로써 작업들을 성취하도록 한다.
결과적으로 인간과 기계 모두의 시간이 절약되며, 금전적으로 더 많은 정보가 실험실 기술로부터 추출될 수 있다.
