
![author](https://img.shields.io/badge/author-daesungRa-lightgray.svg?style=flat-square)
![date](https://img.shields.io/badge/date-190922-lightgray.svg?style=flat-square)

# 애자일과 그것을 넘어서 (To agility and beyond: The history-and legacy-of agile development)

> 출처: <a href="https://techbeacon.com/app-dev-testing/agility-beyond-history-legacy-agile-development" target="_blank">[article]The history of agile</a>

소프트웨어에서 ["Continuous delivery"(지속적 공급)](https://en.wikipedia.org/wiki/Continuous_delivery) 는 특별한 의미 그 이상이다. (more than a buzz phrase.)
그렇다. 소프트웨어의 지속적인 공급은 소프트웨어 개발 관례, 고객 유지의 측면에서 성배이며(holy grail),
이것이야말로 DevOps 가 오늘날 그렇게도 뜨거운 개념이 된 이유이다.
지속적 공급의 중요성을 이해하기 위해서 agility 에 대한 역사와 애자일이 비롯된 지점에 대해 알 필요가 있다.

애자일 소프트웨어 개발의 역사는 [Agile Manifesto(애자일 선언서)](http://techbeacon.com/50-shades-agile-software-development-manifesto) 로부터
시작된 것이 아니다. 그것의 뿌리는 보다 더 이전으로 돌아가야 알 수 있다.
이 기사는 애자일의 근원과 어떻게 더 많은 최신의 지식들이 우리를 매우 빠른 속도로 deliver cycles 로 이끌고 있는지를 포함하는
30년 이상의 소프트웨어 개발 방법론의 진화에 대해 살펴볼 것이다.

- 바로 지금이 당신의 릴리즈 관리 전략을 다시 생각해볼 때가 아닌가? [[왜 적응적 릴리즈 방식이 DevOps 성공의 본질일까? (Gartner)]](https://www.microfocus.com/en-us/assets/application-delivery-management/use-adaptive-release-governance-to-remove-constraints-to-devops?utm_source=techbeacon&utm_medium=techbeacon&utm_campaign=00134846)

## 처음에는 위기가 찾아왔다 (First came the crisis)

PC computing 이 기업 규모로 증식하기 시작하던 1990 년대 초반, 소프트웨어 개발론은 위기를 맞았다.
그때 이것은 "the application development crisis," 또는 "application delivery lag.(소프트웨어 공급 지연)" 와 같이 널리 언급되었다.
산업 전문가들은 비즈니스 요구사항 검증과 실제 제품으로써의 어플리케이션 출시 간에 약 3년의 시간적 편차가 존재한다고 평가했다.

문제는 25년 이전보다 기업들이 더 빠르게 움직이고 있었다는 것이었다.
(출시되기까지) 3년의 공백 안에 요구사항, 시스템, 심지어 전체 비즈니스는 바뀔 가능성이 있었다.
이는 많은 프로젝트의 결과물이 (개발) 도중에 취소되며, 심지어 완성된 결과물 중의 대다수가 프로젝트의 본래 목적과 일치함에도 불구하고
비즈니스의 최신 요구사항에는 부합하지 못했다는 것을 의미했다.

특정 산업에서 지연(the lag)은 3년보다 더 길다. 항공우주방위에서는 복잡한 시스템이 실제 사용 가능해지기까지 20년 이상이 걸리기도 한다.
우주 왕복 프로그램은, 극단적이기는 하지만 결코 특별한 예를 의미하는 것은 아닌데,
1982년에 운용이 시작되기까지 1960년대의 정보처리 기술을 사용했다.
종종 매우 복잡한 하드웨어와 소프트웨어 시스템이 수십년에 걸친 시간적 frame 동안에 디자인, 개발, 그리고 배포된다.

- Get report: [상위 20개의 지속적인 어플리케이션 퍼포먼스 관리 기업들](https://www.microfocus.com/en-us/assets/it-operations-management/research-in-action-continuous-application-performance-management-saas-and-software?utm_source=techbeacon&utm_medium=techbeacon&utm_campaign=00134846)

## 리더들의 좌절 (Thought leaders were frustrated)

1990년대 항공우주 엔지니어인 Jon Kern 는 이러한 긴 진행기간과 향후 바꿀 수 없는 프로젝트 초기에 결정된 사항들에 점점 좌절하고 있었다.
소프트웨어를 만드는 더 좋은 방법이 있어야겠다고 느끼는 사람들이 증가하는 흐름 속에서 그는 다음과 같이 기록했다.
**"우리는 더 시의적절하고 유연한 무언가를 찾고 있었다."**
그는 비공식적으로 모임을 시작하여 절차와 과도한 문서와 당시의 다른 유명한 소프트웨어 엔지니어링 기술 없이
소프트웨어 개발을 보다 단순화하는 방법에 대해 토론하는 17개 소프트웨어 그룹(thought) 리더 중의 하나였다.

다른 산업들도 마찬가지로 변화를 겪고 있었다.
자동차 산업은 새로운 자동차를 디자인하는 것에 6년 혹은 그 이상이 걸렸는데, 1990년대에 이르러서는 그 시간이 거의 절반으로 줄었다.
AT&T 가 해체되었고, 소위 Baby Bells 는 과감하게 휴대전화와 서비스의 비용을 절감했다.

전화기 스위치, 자동차, 또는 비행기와 같이 소프트웨어 개발 컴포넌트가 포함된 제품들에서 소프트웨어는 대개 뒷전이 되고는 했는데,
그 이유는 하드웨어 디자인이 결정되기 전까지는 소프트웨어 개발을 시작할 수 없었기 때문이다.
당시 소프트웨어를 만드는 것은 대부분의 제품 개발 팀에게 우선순위가 아니었다.

## 그리고 애자일이 탄생했다 (And agile was born)

비슷한 생각을 가진 전문가들에 의해 공유된 겉보기에 비생산적인 소프트웨어 개발 활동을 둘러싼 이러한 좌절은
2001년 초반 유타(Utah)에서부터 시작되어 현재 유명한 모임이 된 Snowbird meeting 으로 이어졌다.
그러나 이 특별한 그룹의 소프트웨어 리더들의 만남은 처음이 아니었다.
그들은 일년 전인 2000년 봄 오리곤의 Rogue River Lodge 에서 모였다.

이 그룹은 Kern 을 비롯하여 프로그래밍의 선구자 Kent Beck, Ward Cunningham, Arie van Bennekum, Alistair Cockburn,
그리고 열 두명의 또다른 사람들을 포함하고 있는데, 이들은 애자일 코뮤니티에서 잘 알려진 사람들이다.
초창기 애자일(Agile, as a practice)은 최종 목적지가 아니었다.
사실 "agile" 은 그전에는 아직 공식적인 용어로 사용되지 않았었는데,
그 모임에서는, 참석자 모두가 특별히 만족하지는 못했지만, "가벼운(light)" 그리고 "경량(lightweight)" 과 같은 표현이 더 일반적이었다.

특히, 이 리더들은 동작하는 소프트웨어를 빠르게 빌드하고 그것을 최종사용자에게 전달하는 방법들에 대해서 탐색했다.
이 빠른 공급방식은 다수의 중요한 유익들을 제공했는데, 첫째로 이것은 사용자들로 하여금 새로운 소프트웨어의 비즈니스적 이점을
빠르게 얻을 수 있도록 하였다. 둘째로 이것은 소프트웨어 팀이 소프트웨어의 범주와 방향성에 대한 빠른 피드백을 얻을 수 있도록 하였다.

빠른 피드백과 변화에 대한 열린 자세는 애자일 운동의 주요한 특징이 되었다.
소프트웨어 팀이 사용자의 니즈 이해에 대한 확신이 없을 때 이것은 우선 대략적인 결과물(first approximation)을 전달한 뒤 피드백을 받는다.
그러나 이 경우, 프로젝트의 시작점에서는 매우 적은 내용만 픽스된다.

## 무거운 공정에 대한 반발 (A backlash against heavyweight processes)

애자일은 소프트웨어의 초창기에 종종 활용되어지곤 하던 혼돈스럽고 계획되지 않은 산물들에 대한 응답으로써
1970년대와 1980년대에 만들어진 개발 방법론에 대한 비판을 의미하지는 않는다.
사실 1970년대에서 1990년대까지는 크게 봐서 기초적인 이론들과 소프트웨어 엔지니어링 관례들이 나타나게 된 시기이다.
(애자일) 개념은 소프트웨어 엔지니어링을 물리적 엔지니어링과 동일시하고
그것의 설계와 실제 건축물로부터 가능한 한 많은 것을 차용하는 것이었다.

이 성과는 폭포수 방법론으로 알려지면서 스스로를 드러냈으며,
배포 요구사항으로부터 시작하는 개발 생명주기의 주요한 위상들을 명백하게 정의했다.
이것은 "폭포수(waterfall)" 라고 이름 지어졌는데,
그 이유는 개발 팀이 다음 단계로 넘어가기 전에 완전한 하나의 스텝(폭포수의 한 스텝)을 완료하기 때문이다.
각 단계에 걸쳐서 기능적 설계로 넘어가기 전에 요구사항이 완성되어야 하고, 기능적 설계는 상세 설계 이전에 완료되어야 하는 식이다.
그리고 물이 경사를 거슬러 올라가지 않듯이, 프로세스의 이전 단계로 되돌아가는 규정은 거의 없다.
한번 특정 단계를 끝마치면 해당 단계는 그 시점에 동결된다.

이 방법론은 (물리적 공학으로부터) 소프트웨어 개발의 조직과 엔지니어링 관행의 컨셉을 가져왔으나 (그것과) 주요한 차이점이 있었다.
토목 공학 또는 기계 공학 프로젝트는 십년 혹은 그 이상의 기간동안 좀처럼 변하지 않는다.
만약 오늘날 당신이 교량(다리)이나 고층 건물 설계를 한다면, 일이년 동안은 상세 내용들이 변경되지 않을 가능성이 매우 높다.

사실 본원으로써의 폭포수는 변화와 프로젝트의 결정사항 재검토를 수용하는 것으로 되어 있었다.
그곳에는 이전 단계로 되돌아가는 것을 수용하는 것과 몇몇 결정사항과 기대점들을 조정하는 것,
현재 단계의 관점을 변경할 수 있는 변화들도 존재했다.
그러나 관례적으로 일정과 예산들은 거의 항상 그것이 불가능하도록 했고, 팀으로 하여금 이전의 결정을 고수하도록 강제하였다.

당시에는 계획 세우는 것에 더 많은 시간을 사용하면 코드 작성에 더 적은 시간이 소요되며 코드가 더 좋아진다는 것이
대부분의 소프트웨어 개발 그룹들과 대학의 컴퓨터공학 부서들에게 복음으로 받아들여졌다.
이것은 단지 프로세스 중심의 접근 방식만 강화하여, 작동하는 소프트웨어를 제공하는 것보다 계획을 세우고 문서화하는 것만을 강조했다.

## 동의하지 말라 (We beg to disagree)

소프트웨어 프로젝트들은 전통적인 엔지니어링 프로젝트들과 같은 종류의 안정성을 거의 갖지 못한다.
비즈니스 요구사항은 겉보기에는 하룻밤 새, 분명히는 소프트웨어 어플리케이션 완료에 공식적으로 요구되는 개월수나 연수보다 더 빠른 변화를 필요로 한다.
회고하자면, 소프트웨어는 엔지니어링과는 완전히 다른 접근방법이 요구되는 것이 분명해 보인다.

물론 문제의 다른 부분은 소프트웨어 디자인이 과학과 예술이라는 것과 함께 인간의 한계와 연관된 결점이라는 것에 있다.
첫째로 우리는 어떻게 소프트웨어를 잘 정의할 수 있는지 단순하게 알지 못한다.
사용자들은 그들의 비즈니스 작업 흐름을 설명할 수는 있지만,
소프트웨어 디자이너에게 어떤 특징이 그것을 자동화하며 어떻게 그것들이 동작하게 되는지 말할 수는 없다.
제품 빌드를 시작하기 전에는 무엇이 필요한 지 정확하게 정의할 수 없는 우리의 한계는
대부분의 다른 엔지니어링 분야들로부터 소프트웨어 엔지니어링을 분리시킨다.

둘째로, 불완전한 요구사항을 명세로, 명세를 구현체로 번역해내는 것은 애매모호하다.
그 중 몇몇은 일상에서 쓰여지는 자연어로부터 오는데,
만약 (요구사항의) 설명이 제대로 해석되지 않는다면 그것은 거의 확실하게 잘못 해석된 채로 남는다.
(개발) 팀은 디자인 레벨에서 읽고, 구현의 레벨에서 그것을 번역하기 때문에 실수와 잘못된 이해는 발생할 수밖에 없다.

## 공상가는 소프트웨어 개발에 있어서 다른 시각을 가지고 있다 (Visionaries have different views of software development)

그러한 반발의 일부는 세계에서 가장 큰 소프트웨어 개발자로부터 비롯되었다: 그것은 US 정부이다.
특히, 소프트웨어 개발에 대한 국방부(Department of Defense, DoD) 표준(in particular, DOD-STD-2167)은
반복 프로세스 모델을 지원하기로 명시적으로 변화된 1990년대 후반까지 폭포수 모델에 관해 명백하게 긍정적인 태도를 가지고 있었다.

마침내 DoD 는 자신들만의 프로그래밍 언어를 설계하기에 이르렀다:
Ada Lovelace 의 이름을 딴 에이다(Ada)는 종종 최초의 컴퓨터 프로그래머로 언급된다.
드물게 거대하고 고수준으로 구조화된 언어는 많은 문서와 함께 무거운 프로세스를 요구하는 것으로 보인다.
이것은 고수준의 문서화와 계획화가 진행된 폭포수 프로세스의 시대에 있어서 완벽한 것이었다.

폭포수 모델이 지배적이었던 1980년대와 1990년대였음에도 불구하고, 산업과 학계의 리더들은 뒤로 물러났다.
중요한 최초의 응답은 James Martin 의 [재빠른 어플리케이션 개발(rapid application development)](http://www.projectmanagement.com/content/processes/11306.cfm)
또는 RAD 였다. RAD 의 목적은 준비 단계를 줄이고 빠르게 개발 단계로 진입하여
며칠 혹은 몇주만에 작업 프로토타입을 확인하도록 함으로써 비즈니스가 즉시 개발 팀과의 협력을 시작할 수 있도록 하는 것이었다.

또한 당시에는 소위 반복적 소프트웨어 개발로 불리는 움직임이 존재했다.
반복적 소프트웨어 개발론이 자신의 뿌리를 적어도 1960년대에 두고 있음에도,
점진적 개선론의 개념은 품질 전문가 W.Edwards Deming 과 그 이전의 다른 작업들을 통해 채택되었다.
이 개념은 활동을 수행하고, 필수적 특성을 측정하고, 일반 개념을 변경한 후, 개선을 위해 재측정하는 것이다.

1980년대를 지나며 Gerald Weinberg, Fred Brooks, 그리고 Grady Booch 와 같은 소프트웨어 공상가들은
반복적 개발 기술에 대한 매우 유명한 책과 기사들을 썼다.
맨먼스의 신화(The Mythical Man-Month) 의 저자로 널리 알려진 Fred Brooks 는
소프트웨어 개발 생산성에 있어서 괄목할만 한 진보를 가져올 단일 기술 또는 공정은 없다는 내용을 기록한
_"은탄환은 없다-소프트웨어 공학의 본질과 사고(No Silver Bullet-Essence and Accidents of Software Engineering)"_ 으로 불리는 기사를 썼다.

아마도 1980년대 반복적 개발론 작업으로 가장 많이 알려진 것은 Barry Boehm 의 ["소프트웨어 개발과 향상의 나선 모델"](https://courses.cs.vt.edu/csonline/SE/Lessons/Spiral/Lesson.html) 이다.
이 나선 모델은 작은 규모에서부터 더 많은 형태와 기능이 추가되도록 차근차근 성장하는 프로젝트에 대한 특별한 반복 테크닉이다.
주되고 가장 많이 보이는 프로젝트들은 일반적으로 직접적인 폭포수 모델을 사용하는 동안 이 대체 모델은 배경 속에 숨어 있었다.

## 실무자들은 개발을 반복하기를 원한다. (Practitioners want to iterate development)

이와 동시에 더 많은 반복적인 방법론들이 개발되고 있었다.
예를 들어 Jeff Sutherland 와 Ken Schwaber 는 1990년대 초에 scrum 프로세스를 고안해냈다.
이 용어는 럭비(rugby)로부터 비롯되었으며 공통의 목적지를 향한 팀 working 으로 언급된다.
그들은 Texas 의 Austin 객체지향 컨퍼런스에 헌정하기 위하여 1995년에 scrum 을 성문화했는데,
"SCRUM Software Development Process." 라는 이름의 지면 제목의 형식으로 이것을 출판했다.

Scrum 은 작고 자생적으로 조직된 팀에게 특정 과제가 아닌 목표가 주어졌을 때
새로운 개발, 복잡한 제품, 최고의 결과물이 나타나는 것을 위한다는 개념에 기반하고 있다.
이 팀은 그러한 목표에 도달하기 위한 최상의 방법을 결정할 수 있는 자유를 가지고 있다.
Scrum 은 또한 동작하는 소프트웨어를 전달하기 위한 목표를 가지고 있는 time-boxed 반복 개발 주기를 정의했다.

동시에 Kent Beck 이 Chrysler 의 실험적 소프트웨어 개발 프로젝트의 컨설턴트로 고용되었다.
이 때 그는 프로젝트 리더로 지명되었으며, XP 방법론에 그것의 이름을 부여하면서
극단적인 수준으로써 최상의 사례들을 차용하는 것이 성공을 위한 노력으로써 정의되었다.
그러나 Chrysler 가 인수되면서 이 프로젝트는 궁극적으로 취소되었고,
Beck 은 **Extreme Programming Explained** 라는 제목의 책을 출간했으며,
이로 인해 그의 이름은 대안적 방법론을 이끄는 사람 중의 하나와 동의적인 것이 되었다.

아마 다양한 agile 과 반복적 기술들은 여전히 2001년 Snowbird 모임에서 고안된 Agile 선언서를 위한 것이 아닌 비주류의 영역에 머물고 있을 것이다.
이 그룹의 불확실한 목표에도 불구하고, 이 선언서는 당시 여전히 널리 퍼져 있는 폭포수 모델에 대해 반하는 접근방식의 목표에 대한 가장 깔끔하고 가장 간결한 진술이다.

결과적으로 소프트웨어 개발 커뮤니티는 Agile 선언서와 agile 소프트웨어 개발 운동의 결정적인 진술로써의 그것의 12 개의 원리 위에 굳어졌다.
오늘날 더욱더 많은 팀들이 그들 스스로를 agile 방법론을 사용한다고 정의하고 있다.
그러한 팀들 중 다수가 여러 agile 방법론의 요소들을 폭포수만큼이나 포함하고 있는 복합 모델을 사용하는 것으로 보여지는 와중에,
그들은 agile 운동이 그런 진술의 능력과 그런 운동의 힘 둘 다에 있어서 성서로 자리매김하고 있다고 완전히 구별하고 있다.

## agility 를 향해, 그리고 그것을 넘어서 (To agility, and beyond)

그리고 agility 는 우리를 우리가 있는 곳으로 데려가지만, 이것이 이야기의 마지막이 아니다.
agile 을 넘어서 삶이 있고, 
