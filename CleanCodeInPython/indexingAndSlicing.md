
![author](https://img.shields.io/badge/author-daesungRa-lightgray.svg?style=flat-square)
![date](https://img.shields.io/badge/date-190602-lightgray.svg?style=flat-square)

# [파이썬스러운 코드] 인덱스와 슬라이스

## 관용구?

- 프로그래밍에서 관용구(idiom)는 특정 작업을 수행하기 위해 코드를 작성하는 특별한 방법이다.
- 같은 작업이라도 언어에 따라 고유의 관용적인 코드 작성법이 존재한다.
- 파이썬에도 파이썬만의 관용구가 존재하며(이는 실제 코드로 구현된다는 점에서 디자인 패턴과는 다르다),
- 이것을 따른 코드를 파이썬스럽다(Pythonic)고 한다.
- 관용구의 이점
    * 일반적으로 더 나은 성능을 낼 수 있음
    * 협업 시 동일한 패턴과 구조에 익숙한 개발 팀 전체가 실수를 줄이고 문제의 본질에 보다 집중할 수 있다.

## 인덱스와 슬라이스

- 흔히 알고 있는 파이썬의 간편한 인덱싱, 음수 인덱싱, 슬라이싱 등은 파이썬 내장 함수인 **slice(시작, 중지, 간격)** 를 전달하는 것이다.
- 그러므로 이 함수를 직접 빌드하여 전달할 수도 있다.
- 활용법은 인덱싱하고자 하는 sequence 객체에 동일한 방식으로 전달하면 된다.

> 튜플, 문자열, 리스트의 특정 요소를 가져오려고 한다면 for 루프를 돌며 수작업으로 선택하지 말고 slice 객체를 활용하는 방법을 사용할 것!

## 자체 시퀀스 생성

- 표준 라이브러리에 있는 시퀀스 객체는 **\_\_getitem\_\_** 과 **\_\_len\_\_** 이라는 **magic method** 를 구현하고 있으므로 이와 같이 간략한 반복사용이 가능했다.
- 내부적으로는 해당 sequence 의 key 에 해당하는 대괄호 안의 값을 가져오는 방식으로 동작한다.
- 이를 응용하여 시퀀스나 이터러블 객체를 만들지 않고 키로 객체의 특정 요소를 가져오는 사용자 정의 클래스를 만들 수 있다.
- 다음은 캡슐화 방식을 활용한 예제이다.
```python
class Items:
    def __init__(self, *values):
        self._values = list(values)
    
    def __len__(self):
        return len(self._values)
    
    def __getitem__(self, item):
        return self._values.__getitem__(item)
```
- 캡슐화 말고 상속을 사용할 수도 있는데, 이것은 기존의 내장 객체를 wrapper 로 감싸는 방식이므로 안정적이다.
- 또한, list 객체를 감싸는 사용자정의 wrapper 인 위 예제 클래스는 ```collections.UserList``` 클래스를 상속받아야만 한다.
- 이 부모 클래스는 **리스트 객체를 감싸는 보다 완전한 사용자정의 wrapper** 라고 docstring 문서화되어 있다.(help())
- 만약 이러한 기반 없이 사용자정의 시퀀스를 작성하려면, 다음의 두 사항에 유의해야 한다.
    * **범위로 인덱싱하는 결과는 해당 클래스와 같은 타입의 인스턴스여야 한다** : 당연하지 않은가..
    * **slice 에 의해 제공된 범위는 파이썬이 하는 것처럼 마지막 요소는 제외해야 한다** : 일관성의 이유




