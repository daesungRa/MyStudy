![author](https://img.shields.io/badge/author-daesungRa-lightgray.svg?style=flat-square)
![date](https://img.shields.io/badge/date-190113-lightgray.svg?style=flat-square)

# 자바 기본개념 및 Command Line 환경에서 Java 컴파일하기

> 나는 자바를 이클립스와 함께 시작했기 때문에, 프로젝트 생성 및 컴파일, 빌드, 실행의 전반적인 절차가 자동으로 이루어지는 환경에 익숙해졌다. 그러나 이런 IDE 가 존재하지 않은 자바의 초창기 시절도 있었을 것이고, 선대 개발자들은 그러한 환경에서도 얼마든지 코딩을 해왔을 것이다.

> 오늘날 내가 누리는 편리한 환경은 그런 척박한 상황을 개선하기 위한 지속적인 노력의 산물이므로, 아무 생각 없이 누리기만 할 것이 아니라 그들이 느꼈던 불편함, 개선하고자 했던 노력을 조금이나마 경험하기 위해 다음 내용을 간략히 정리한다.

> 추가적으로, 커맨드라인 환경에서 날코딩 하는 경험을 통해 자바 프로젝트가 운용되는 토대를 이해하고 직접 명령을 통한 컴파일 및 실행 과정을 학습한다. 이것은 유사시 대처 능력을 높여줄 것이라고 믿는다.

- 공부 내용 요약
	* 자바 기본 개념 학습
	* Singleton 예제를 직접 작성하면서 javac, java 명령으로 직접 컴파일 후 실행하는 과정 학습
## 목차

[자바 기본 개념 정리](#자바-기본-개념-정리)
[자바 프로젝트 생성 및 실행](#자바-프로젝트-생성-및-실행)
[느낀점](#느낀점)

## 자바 기본 개념 정리

Java 언어는,
- 대표적인 객체지향 언어이며
- 상속, 모듈화, 다형성 등의 개념을 구현하기 용이하다 (모듈 간 결합도를 낮추고 응집도를 높이는 방향으로 개발 가능)
- JVM 에 의해 여러 OS 환경에서 운용 가능하기 때문에 이식성이 높고
- GC 에 의해 메모리를 자동 관리하기 때문에 메모리 관리에 관련된 개발자의 부담이 상대적으로 적다

### Java Virtual Machine ([JVM])

- 일단 모든 자바 프로젝트 및 파일들은 자바가상머신에 의해 관리된다. JVM 은 프로그램이 실행되는 OS 와 사용자 사이의 중재자 역할로써, 사용자는 JVM 덕분에 환경에 상관 없이 자바 언어로 구성된 프로그램의 실행이 가능하다.
- 개발자 입장에서도 JVM 은 개발자가 고려해야 할 메모리 관리를 자동으로 수행해주며(GC), OS 환경을 크게 고려하지 않고 코딩할 수 있도록 도와주므로 부담이 줄고 생산성이 높아진다.
- 구체적으로 JVM 은 최초 OS 로부터 프로그램 실행을 위한 메모리를 할당받아 각 기능에 따라 영역을 나눈다
- 이후 자바 컴파일러(javac.exe)에 의해 번역된 바이트 코드(byte code)를 자신이 접촉하고 있는 OS 에 맞게 해석하는 방식으로 동작.
- 이 과정은 클래스 파일을 로드하는 클래스로더, 그것을 해석하는 실행 엔진으로 구성된다

### 메모리 구조와 GC ([GC])

- JVM 은 메모리를 크게 세 영역으로 나누어 자바 소스를 관리한다
	* **메서드(Method)** 영역 : 자바 프로젝트의 최초 구동 시 [자바 클래스 로더]의 Execution Engine 에 의해 목적 클래스파일이 해석되어 적재된다. 클래스 영역이라고도 한다
	* **힙(Heap)** 영역 : 클래스 영역에 로드된 정보를 토대로 실제 **객체 인스턴스**를 생성해 할당해 두는 영역
	* **스택(Stack)** 영역 : 메인 메서드가 [스택] 방식으로 실행되는 영역. FILO (LIFO) 방식으로 단계별 누적 실행된다
- Garbage Collection
	* Heap 영역에서만 동작하며, 생성된 인스턴스 중 참조되지 않는 객체가 있다면 쓰레기(garbage) 로 간주하여 할당 해제한다
	* 자동 메모리 관리(automatic memory management) 알고리즘에 의해 동작 (참조 수에 따른 우선순위)
	* 개발자는 GC 에 의해 메모리가 관리되도록 두어야 하며 (사실 별 방법도 없음), 그나마 할 수 있는 처리는 **System.gc();** 로 GC 가 최대한 우선적으로 작업하도록 호출하는 것뿐이다

![JVM 구조](https://github.com/daesungRa/MyStudy/blob/master/imgs/JVM.png)
```
GC 는 클래스 로더와 같은 수준에서 힙 영역에 대해 동작하며,<br/>
네이티브 메서드 영역은 자바 이외의 언어로 작성된 네이티브 코드를 Java Native Interface(JNI) 로 호출해 적재하는 공간이다.<br/>
PC 레지스터는 현재 수행 중인 JVM 명령의 주소를 저장하며, 각 스레드가 어떤 식으로 동작해야되는지에 대한 데이터를 처리한다
```

### 절차지향 패러다임과의 비교

- 절차지향과 객체지향 패러다임
	* 절차지향의 가장 큰 장점은 (상대적으로)빠른 처리속도이다. 일반적인 객체지향 언어에 비해 컴퓨터적 처리절차에 맞게 작성되기 때문이다
	* 그러나 프로젝트의 규모가 커지고 사용되는 부품의 종류가 많아질수록 코드를 해석하기 어렵고, 나아가 유지보수에 상당히 비효율적이다. 특히 협업 위주의 대규모 프로젝트에서는 제한점이 많다.
	* 반면 객체지향 언어는 처리절차의 흐름보다 각 데이터 간의 처리 및 참조관계를 중시하여, 기능이나 데이터 속성에 따라서 부품화하므로, 대규모 프로젝트에 적합하다
	* 상속 및 캡슐화와 같은 객체지향의 특성은 모듈의 재사용성, 유지보수의 측면에서 유리하다
	* 그러나 계속 언급하듯이 처리속도에 상대적으로 불리하며, 설계가 까다로워 프로젝트 구조가 불필요하게 장황해질 수 있다
- 메모리 관리 측면 (C 와 Java)
	* C 와 같은 저수준 언어는 작성자가 직접 메모리 관리나 데이터 타입 및 사이즈 지정작업을 수행해야 한다
	* 그러나 메모리 관리를 자동으로 하는 자바의 특성은, 기성복과 맞춤복의 차이처럼 자바를 속도 및 메모리 최적화의 측면에서 상대적으로 불리하게 만든다. (물론 범용성과 이식성의 측면에서는 월등한 이점이 있다)
	* 만약 네이티브 앱이나 특수목적을 위한 연구용 프로그램, 고사양을 요하는 게임 프로그램을 위해서는 빠른 성능, 처리속도가 장점인 C 계열 언어를 사용하는게 맞지만,
	* 구조적으로 인프라가 넓고 대용량 데이터를 유기적으로 관리해야 하는 프로그램(웹앱과 같이)에서는 규모에 따라 효율적인 개발 생산성과 범용성 및 이식성의 장점이 있는 객체지향 언어를 사용하는 것이 좋다
- JVM 과 GC 의 사용여부도 하나의 차이점으로 볼 수 있다

## 자바 프로젝트 생성 및 실행

- 예제 : Singleton 프로젝트

1. **환경 설정**
	* java 1.8.0 설치 후 시스템 혹은 유저별 환경변수 세팅 (JAVA_HOME, classpath) 을 통해 어느 위치에서든 자바 명령을 실행할 수 있도록 한다. 많이 해봤으므로 스킵.

2. **프로젝트 생성**
	* 프로젝트명 : SingletonPjt
	* 패키지명 : singletonEx
	* 자바 프로젝트 구조
		- 지정된 워크스페이스에 생성된 프로젝트 홈 디렉토리를 생성 (~/SingletonPjt/). 일관성을 위해 홈 위치에서 코딩 및 컴파일을 진행한다.
![홈 디렉토리 생성](https://github.com/daesungRa/MyStudy/blob/master/imgs/singletonEx01.png)
		- home dir 하위에 바이너리 디렉토리와 소스 디렉토리 생성 (./bin ./src).
		- 소스 디렉토리-패키지 하위에 필요한 자바 파일을 생성하고 코딩
![바이너리 및 소스 디렉토리 생성](https://github.com/daesungRa/MyStudy/blob/master/imgs/singletonEx02.png)

<br/>이해를 위한 이클립스 프로젝트 구성화면<br/>
![자바 프로젝트 전체구조](https://github.com/daesungRa/MyStudy/blob/master/imgs/JavaProjectStructure.png)
```
이클립스에서 바이너리 디렉토리는 나타나지 않지만 실제 경로에는 존재하며,
소스코드를 컴파일한 클래스 파일이 자동으로 생성되어 해당 위치에 저장된다
```


3. 소스코드 작성
	* 소스코드는 소스 디렉토리에만 작성
	* 싱글톤 클래스의 생성자가 호출될 때마다 1 씩 증가하는 static int 변수를 갖는 Serial 클래스 작성
	* 싱글톤 클래스 작성. getInstance() 만 호출 가능하며, 전역 객체가 존재하면 그것을 리턴하고 존재하지 않으면 생성자로 생성하여 리턴한다.
	* 생성여부 확인을 위해 static serial 변수를 필드로 추가, 생성자에서 Serial 클래스의 전역변수를 1 증가시키고 해당 변수가 그것을 참조하도록 한다
	* 싱글톤 테스트 메인 메서드에서 차례대로 출력하며 확인한다
	* 소스 간 의존관계
		- Serial.java > Singleton.java > SingletonTest.java 순이다
		- 왜 그런지는 아래 코드 내용을 보면서 한번 생각해볼 것
		- 이 의존관계에 따라 순차적으로 컴파일하고, 최종적으로 테스트파일을 실행한다
<br/>Serial.java<br/>
![Serial.java](https://github.com/daesungRa/MyStudy/blob/master/imgs/singletonEx_Serial.png)
<br/>Singleton.java<br/>
![Singleton.java](https://github.com/daesungRa/MyStudy/blob/master/imgs/singletonEx_Singleton.png)
<br/>SingletonTest.java<br/>
![SingletonTest.java](https://github.com/daesungRa/MyStudy/blob/master/imgs/singletonEx_Test.png)

4. **컴파일 및 실행**
	* 자바 관련 실행 프로그램은 시스템에 지정한 Java 경로 내 bin (바이너리, 실행 파일들의 모음) 디렉토리 내에 위치한다
	* 컴파일은 자바 컴파일러(javac.exe) 로, 실행은 자바 실행 명령(java) 으로 수행. 이하 설명

### javac

- 구성
	* javac [옵션] [목적 자바 소스파일]
- 옵션
	* -d : 컴파일된 클래스파일이 생성되는 경로를 지정
	* -classpath : 의존관계에 있다면, 의존하는 클래스파일이 존재하는 경로를 지정
	* 이 밖에 더 있지만 위 두 개가 주요하므로 나머지는 추후 공부해볼 것

![컴파일 결과](https://github.com/daesungRa/MyStudy/blob/master/imgs/singletonEx03.png)
1. Singleton.java 파일에 의해 의존되는(참조되는) Serial.java 먼저 컴파일한다
2. 그 다음인 Singleton.java 컴파일
3. 최종적으로 싱클톤 클래스를 로드해 메인 메서드로 출력하는 테스트 파일 컴파일
4. 바이너리 디렉토리에 실행 파일들이 생성된 것을 확인할 수 있다

### java

- 구성
	* java [옵션] [목적 클래스 실행파일]
- 옵션
	* -classpath : 의존관계에 있다면, 의존하는 클래스파일이 존재하는 경로를 지정
	* 이 밖에 더 있지만 위 두 개가 주요하므로 나머지는 추후 공부해볼 것

![실행 화면](https://github.com/daesungRa/MyStudy/blob/master/imgs/singletonEx04.png)
1. 의존관계를 명시하고(-classpath) 실행 파일을 실행한다([패키지명.클래스파일명])
2. 싱글톤 테스트 결과가 출력된 것을 확인

## 느낀점

- 보이지 않는 영역에서 JVM 과 GC 가 동작하는 과정에 대한 이해가 생김
- 절차지향과 객체지향 패러다임에 대한 이해가 생김
- 컨트롤 + F11 이면 자동으로 수행되는 컴파일, 빌드, 실행 작업이 그리 간단치만은 않은 절차로 이루어진다는 것 확인 (의존관계에 따른 순차 컴파일 등)
- 추후 유사시 자바만 설치되어 있다면 날코딩으로도 작업을 할 수 있겠다는 생각을 함

#### 참조

[JVM]<br/>
[자바 클래스 로더]<br/>
[스택]<br/>
[GC]<br/>

[JVM]: https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0
[자바 클래스 로더]: https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94
[스택]: https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%83%9D
[GC]: https://d2.naver.com/helloworld/1329
















