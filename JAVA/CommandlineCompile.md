![author](https://img.shields.io/badge/author-daesungRa-lightgray.svg?style=flat-square)
![date](https://img.shields.io/badge/date-190113-lightgray.svg?style=flat-square)

# 자바 기본개념 및 Command Line 환경에서 Java 컴파일하기

> 나는 자바를 이클립스와 함께 시작했기 때문에, 프로젝트 생성 및 컴파일, 빌드, 실행의 전반적인 절차가 자동으로 이루어지는 환경에 익숙해졌다. 그러나 이런 IDE 가 존재하지 않은 자바의 초창기 시절도 있었을 것이고, 선대 개발자들은 그러한 환경에서도 얼마든지 코딩을 해왔을 것이다.

> 오늘날 내가 누리는 편리한 환경은 그런 척박한 상황을 개선하기 위한 지속적인 노력의 산물이므로, 아무 생각 없이 누리기만 할 것이 아니라 그들이 느꼈던 불편함, 개선하고자 했던 노력을 조금이나마 경험하기 위해 다음 내용을 간략히 정리한다.

> 추가적으로, 커맨드라인 환경에서 날코딩 하는 경험을 통해 자바 프로젝트가 운용되는 토대를 이해하고 직접 명령을 통한 컴파일 및 실행 과정을 학습한다. 이것은 유사시 대처 능력을 높여줄 것이라고 믿는다.

- 공부 내용 요약
	* 자바 기본 개념 학습
	* Singleton 예제를 직접 작성하면서 javac, java 명령으로 직접 컴파일 후 실행하는 과정 학습

## 자바 개념 및 프로젝트 구조 파악

Java 언어는,
- 대표적인 객체지향 언어이며
- 상속, 모듈화, 다형성 등의 개념을 구현하기 용이하다 (모듈 간 결합도를 낮추고 응집도를 높이는 방향으로 개발 가능)
- JVM 에 의해 여러 OS 환경에서 운용 가능하기 때문에 이식성이 높고
- GC 에 의해 메모리를 자동 관리하기 때문에 개발자의 부담이 상대적으로 적다

### Java Virtual Machine ([JVM])

- 일단 모든 자바 프로젝트 및 파일들은 자바가상머신에 의해 관리된다. JVM 은 프로그램이 실행되는 OS 와 사용자 사이의 중재자 역할로써, 사용자는 JVM 덕분에 환경에 상관 없이 자바 언어로 구성된 프로그램의 실행이 가능하다.
- 개발자 입장에서도 JVM 은 개발자가 고려해야 할 메모리 관리를 자동으로 수행해주며(gc), OS 환경을 크게 고려하지 않고 코딩할 수 있도록 도와주므로 부담이 줄고 생산성이 높아진다.
- 구체적으로 JVM 은 자바 컴파일러에 의해 번역된 바이트 코드(byte code)를 자신이 접촉하고 있는 OS 에 맞게 해석하는 방식으로 동작한다

### 메모리 구조와 GC

- JVM 은 메모리를 크게 세 영역으로 나누어 자바 소스를 관리한다
	* **네이티브 메서드**(Native Method) 영역 : 자바 프로젝트의 최초 구동 시 [자바 클래스 로더]에 의해 필요한 클래스 및 메서드들이 로드된다
	* **힙**(Heap) 영역 : 클래스 영역에 로드된 정보를 토대로 실제 객체 인스턴스를 생성해 할당해 두는 영역
	* **스택**(Stack) 영역 : 메인 메서드가 [스택] 방식으로 실행되는 영역. FILO 방식으로 단계별 누적 실행된다
- Garbage Collection ([GC])
	* 오직 Heap 영역에서만 동작하며, 생성된 인스턴스 중 참조되지 않는 객체가 있다면 쓰레기(garbage) 로 간주하여 할당 해제한다
	* 자동 메모리 관리(automatic memory management) 알고리즘에 의해 동작
	* 개발자는 GC 에 의해 메모리가 관리되도록 두어야 하며 (사실 별 방법도 없음), 그나마 할 수 있는 처리작업은 **System.gc();** 로 가급적 우선적으로 작업하도록 호출하는 것뿐이다

### 절차지향 패러다임과의 비교

- 절차지향과 객체지향 패러다임
	* 절차지향의 가장 큰 장점은 (상대적으로)빠른 처리속도이다. 일반적인 객체지향 언어에 비해 컴퓨터적 처리절차에 맞게 작성되기 때문이다
	* 그러나 프로젝트의 규모가 커지고 사용되는 부품의 종류가 많아질수록 코드를 해석하기 어렵고, 나아가 유지보수에 상당히 비효율적이다. 특히 협업 위주의 대규모 프로젝트에서는 제한점이 많다.
	* 반면 객체지향 언어는 처리절차의 흐름보다 각 데이터 간의 처리 및 참조관계를 중시하여, 기능이나 데이터 속성에 따라서 부품화하므로, 대규모 프로젝트에 적합하다
	* 상속 및 캡슐화와 같은 객체지향의 특성은 모듈의 재사용성, 유지보수의 측면에서 유리하다
	* 그러나 계속 언급하듯이 처리속도에 상대적으로 불리하며, 설계가 까다로워 프로젝트 구조가 불필요하게 장황해질 수 있다
- 메모리 관리 측면 (C 와 Java)
	* C 와 같은 저수준 언어는 작성자가 직접 메모리 관리나 데이터 타입 및 사이즈 지정작업을 수행해야 한다
	* 그러나 메모리 관리를 자동으로 하는 자바의 특성은, 기성복과 맞춤복의 차이처럼 자바를 속도 및 메모리 최적화의 측면에서 상대적으로 불리하게 만든다. (물론 범용성과 이식성의 측면에서는 월등한 이점이 있다)
	* 만약 네이티브 앱이나 특수목적을 위한 연구용 프로그램, 고사양을 요하는 게임 프로그램을 위해서는 빠른 성능, 처리속도가 장점인 C 계열 언어를 사용하는게 맞지만,
	* 구조적으로 인프라가 넓고 대용량 데이터를 유기적으로 관리해야 하는 프로그램(웹앱과 같이)에서는 규모에 따라 효율적인 개발 생산성과 범용성 및 이식성의 장점이 있는 객체지향 언어를 사용하는 것이 좋다
- JVM 과 GC 의 사용여부도 하나의 차이점으로 볼 수 있다

## 자바 프로젝트 생성하기 - 예제) Singleton 프로젝트

- 환경 변수 설정 : 자바 설치 후 시스템 혹은 유저별 환경변수 세팅을 통해 어느 위치에서든 자바 명령을 실행할 수 있도록 한다. 많이 해봤으므로 스킵.
- 

## javac

- 자바 관련 명령 프로그램은 지정한 자바 경로 내 bin (바이너리, 실행 파일들의 모음) 디렉토리 내에 위치한다

## java

## 느낀점

#### 참조

[JVM]<br/>
[자바 클래스 로더]<br/>
[스택]<br/>
[GC]<br/>

[JVM]: https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0
[자바 클래스 로더]: https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94
[스택]: https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%83%9D
[GC]: https://d2.naver.com/helloworld/1329
















