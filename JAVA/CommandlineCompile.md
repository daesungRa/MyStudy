![author](https://img.shields.io/badge/author-daesungRa-lightgray.svg?style=flat-square)
![date](https://img.shields.io/badge/date-190113-lightgray.svg?style=flat-square)

# 자바 기본개념 및 Command Line 환경에서 Java 컴파일하기

> 나는 자바를 이클립스와 함께 시작했기 때문에, 프로젝트 생성 및 컴파일, 빌드, 실행의 전반적인 절차가 자동으로 이루어지는 환경에 익숙해졌다. 그러나 이런 IDE 가 존재하지 않은 자바의 초창기 시절도 있었을 것이고, 선대 개발자들은 그러한 환경에서도 얼마든지 코딩을 해왔을 것이다.

> 오늘날 내가 누리는 편리한 환경은 그런 척박한 상황을 개선하기 위한 지속적인 노력의 산물이므로, 아무 생각 없이 누리기만 할 것이 아니라 그들이 느꼈던 불편함, 개선하고자 했던 노력을 조금이나마 경험하기 위해 다음 내용을 간략히 정리한다.

> 추가적으로, 커맨드라인 환경에서 날코딩 하는 경험을 통해 자바 프로젝트가 운용되는 토대를 이해하고 직접 명령을 통한 컴파일 및 실행 과정을 학습한다. 이것은 유사시 대처 능력을 높여줄 것이라고 믿는다.

- 공부 내용 요약
	* 자바 기본 개념 학습
	* Singleton 예제를 직접 작성하면서 javac, java 명령으로 직접 컴파일 후 실행하는 과정 학습

## 자바 개념 및 구조 파악

Java 언어는,
- 대표적인 객체지향 언어이며
- 상속, 모듈화, 다형성 등의 개념을 구현하기 용이하다 (모듈 간 결합도를 낮추고 응집도를 높이는 방향으로 개발 가능)
- JVM 에 의해 여러 OS 환경에서 운용 가능하기 때문에 이식성이 높고
- GC 에 의해 메모리를 자동 관리하기 때문에 개발자의 부담이 상대적으로 적다

### [JVM]

- 일단 모든 자바 프로젝트 및 파일들은 자바가상머신(JVM)에 의해 관리된다. JVM 은 프로그램이 실행되는 OS 와 사용자 사이의 중재자 역할로써, 사용자는 JVM 덕분에 환경에 상관 없이 자바 언어로 구성된 프로그램의 실행이 가능하다.
- 개발자 입장에서도 JVM 은 개발자가 고려해야 할 메모리 관리를 자동으로 수행해주며(gc), OS 환경을 크게 고려하지 않고 코딩할 수 있도록 도와주므로 부담이 줄고 생산성이 높아진다.
- 구체적으로 JVM 은 자바 컴파일러에 의해 번역된 바이트 코드(byte code)를 자신이 접촉하고 있는 OS 에 맞게 해석하는 방식으로 동작한다

### 메모리 구조와 GC

- JVM 은 메모리를 크게 세 영역으로 나누어 자바 소스를 관리한다
	* 네이티브 메서드(Native Method) 영역 : 자바 프로젝트의 최초 구동 시 [자바 클래스 로더]에 의해 필요한 클래스 및 메서드들이 로드됨
	* 힙(Heap) 영역
	* 스택(Stack) 영역

### C 와의 비교/

- 다만, C 와 같이 메모리나 데이터 타입(사이즈)을 직접 관리하는 저수준 언어에 비해 메모리 관리를 자동으로 해준다는 것은 기성복과 맞춤복의 차이처럼 속도 및 메모리 최적화의 측면에서 상대적으로 불리하다. (물론 범용성과 이식성의 측면에서는 월등한 이점이 있다)

## 자바 프로젝트 생성하기 - 예제) Singleton 프로젝트

- 환경 변수 설정 : 자바 설치 후 시스템 혹은 유저별 환경변수 세팅을 통해 어느 위치에서든 자바 명령을 실행할 수 있도록 한다. 많이 해봤으므로 스킵.
- 

## javac

- 자바 관련 명령 프로그램은 지정한 자바 경로 내 bin (바이너리, 실행 파일들의 모음) 디렉토리 내에 위치한다

## java

## 느낀점

#### 참조

[JVM]: https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0
[자바 클래스 로더]: https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94
















